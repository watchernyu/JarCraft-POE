package genetic;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

import bwmcts.sparcraft.Game;
import bwmcts.sparcraft.GameState;
import bwmcts.sparcraft.Game_POE_Simulation;
import bwmcts.sparcraft.players.Player;
import bwmcts.sparcraft.players.Player_NoOverKillAttackValue;

public class Population_final_with_cross {
	//population that keeps all the chromosomes 
	private int us_id;//id of this player
	private int enemy_id;
	
	public boolean showEvolutionProcess = false;
	public double mutateRate = 0.2;
	public int numMutateEachSuperior = 3;
	//number of offspring generated by mutation
	//for each of the best ones in population
	public int numOfBest = 4;
	//n best ones to select
	//in each generation
	public int generation;
	public int bestscore;
	//public ArrayList<ArrayList<ArrayList<Integer>>> DNAs;
	public ArrayList<Beast> beasts;
	//a chromosome

	public int futureSteps;
	public int numOfMutations;
	public int numOfScripts;
	public int numOfBeasts;
	public int numOfUnits;
	public long STARTTIME = 0;
	public long TIMELIMIT = 20000000;

	private int evalGameRoundLimit = 25;
	//monte carlo simulation with NOKAV round limit
	private Random ran;
	private GameState state; //THIS WILL NOT BE UPDATED SO EACH TIME IN GETMOVES() 
	private ArrayList<Player> scripts;
	private Player player;
	
	private Player NOKplayerForEval1;
	private Player NOKplayerForEval2;
	//used for playout

	//NEED TO CREATE A NEW POPULATION
	public Population_final_with_cross(Player player,GameState state,int futureSteps, int numOfScripts,int numOfUnits,ArrayList<Player> scripts) {
		this.state = state;
		this.generation = 0;
		this.futureSteps = futureSteps;
		this.numOfUnits = numOfUnits;
		this.numOfScripts = numOfScripts;
		this.ran = new Random();
		this.scripts = scripts;
		this.player = player;
		this.beasts = new ArrayList<Beast>();
		
		this.us_id = player.ID();
		this.enemy_id = GameState.getEnemy(this.us_id);
		
		NOKplayerForEval1 = new Player_NoOverKillAttackValue(0);
		NOKplayerForEval2 = new Player_NoOverKillAttackValue(1);
	}
	
	public void reinitialize(GameState s,long starttime){
		this.state = s;
		this.STARTTIME = starttime;
		beasts.clear();
		initialize();
	}
	
	public void reinitializeRandom(GameState s,long starttime){
		this.state = s;
		this.STARTTIME = starttime;
		beasts.clear();
		initializeRandom();
	}

	public void initialize(){
		int basicScore = 0;
		for(int p=0;p<1;p++){
			ArrayList<ArrayList<Integer>> DNA = new ArrayList<ArrayList<Integer>>();
			for(int k=0;k<futureSteps;k++){
				DNA.add(new ArrayList<Integer>());
				for(int i=0;i<numOfUnits;i++){
					DNA.get(k).add(0); //for now, all start with pure NOKAV scripts.
				}
			}
			int score = evalDna(state,DNA);
			basicScore=score;
			beasts.add(new Beast(DNA,score));
		}
		
		for(int p=0;p<5;p++){
			ArrayList<ArrayList<Integer>> DNA = new ArrayList<ArrayList<Integer>>();
			for(int k=0;k<futureSteps;k++){
				DNA.add(new ArrayList<Integer>());
				for(int i=0;i<numOfUnits;i++){
					DNA.get(k).add(0); //for now, all start with pure NOKAV scripts.
				}
			}
			beasts.add(new Beast(DNA,basicScore));
		}
		select();
		//select the best ones and discard the others
	}
	
	public void initializeRandom(){
		//2 NOKAV, rest is random.
		for(int p=0;p<2;p++){
			ArrayList<ArrayList<Integer>> DNA = new ArrayList<ArrayList<Integer>>();
			for(int k=0;k<futureSteps;k++){
				DNA.add(new ArrayList<Integer>());
				for(int i=0;i<numOfUnits;i++){
					DNA.get(k).add(0); //this one all start with pure NOKAV scripts.
				}
			}
			int score = evalDna(state,DNA);
			beasts.add(new Beast(DNA,score));
		}
		
		for(int p=0;p<4;p++){//HARDCODED 4
			ArrayList<ArrayList<Integer>> DNA = new ArrayList<ArrayList<Integer>>();
			for(int k=0;k<futureSteps;k++){
				DNA.add(new ArrayList<Integer>());
				for(int i=0;i<numOfUnits;i++){
					DNA.get(k).add(ran.nextInt(scripts.size())); //for now, all start with pure NOKAV scripts.
				}
			}
			int score = evalDna(state,DNA);
			beasts.add(new Beast(DNA,score));
		}
		select();
	}
	
	public void evolveOnlyMutate(int rounds){//continue evolving for a certain rounds
		for(int i=0;i<rounds;i++){
			mutateOnly();
			select();
		}
	}
	
	public void evolveWithCross(int rounds){//continue evolving for a certain rounds
		for(int i=0;i<rounds;i++){
			mutateAndCross();
			select();
		}
	}
	
	public ArrayList<ArrayList<Integer>> bestDna(){
		return beasts.get(0).getDna();
	}
	
	public void printHighScore(){
		System.out.println("Current high scores in population: ");
		for (int i=0;i<4;i++){
			System.out.print(beasts.get(i).score+" ");
		}
		System.out.println();
	}
	
	public void select(){//basically discard all the beasts that are less valuable..
		Collections.sort(beasts);
		generation ++;

		ArrayList<Beast> tempbeasts = new ArrayList<Beast>();
		for (int i=0;i<6;i++){//HARDCODED
			tempbeasts.add(beasts.get(i));
		}
		beasts.clear();
		beasts = tempbeasts;
		if(showEvolutionProcess){
			System.out.println("Generation: "+generation);//only for testing
			showBeasts();//only for testing
		}
		//System.out.println(beasts.size());
	}
	
	public void showBeasts(){//will display the all the beasts in population, along with their scores.
		int n = beasts.size();
		for(int i=0;i<n;i++){
			beasts.get(i).printDnaAndScore();
		}
	}
	
	public void mutateOnly(){
		for(int index =0;index<numOfBest;index++){//the best some dnas are used to mutate
			ArrayList<ArrayList<Integer>> currentDna = beasts.get(index).getDna();
			for(int m=0;m<numMutateEachSuperior;m++){//each superior DNA will be mutated some times
				if((System.nanoTime()-STARTTIME)>TIMELIMIT){return;}
				ArrayList<ArrayList<Integer>> newDna = mutateDna(currentDna);
				int score = evalDna(state,newDna);
				beasts.add(new Beast(newDna,score));
			}
		}
	}
	
	public void mutateAndCross(){
		int nCross = 6;
		int nBest = 6;
		int nMutateEachBest = 1;
		
		for(int index =0;index<nBest;index++){
			ArrayList<ArrayList<Integer>> currentDna = beasts.get(index).getDna();
			for(int m=0;m<nMutateEachBest;m++){
				if((System.nanoTime()-STARTTIME)>TIMELIMIT){return;}
				ArrayList<ArrayList<Integer>> newDna = mutateDna(currentDna);
				int score = evalDna(state,newDna);
				beasts.add(new Beast(newDna,score));
			}
		}
		
		//BELOW IS NEW CROSS OVER!!!
		for(int i =0;i<nBest;i++){
			int pair = ran.nextInt(nBest-1);
			pair = (i+pair)%nBest;
			ArrayList<ArrayList<Integer>> parentA = beasts.get(i).getDna();
			ArrayList<ArrayList<Integer>> parentB = beasts.get(pair).getDna();
			ArrayList<ArrayList<Integer>> newDna = crossOver(parentA,parentB);
			int score = evalDna(state,newDna);
			beasts.add(new Beast(newDna,score));
		}
		
		//System.out.println(beasts.size());
	}
	
	public ArrayList<ArrayList<Integer>> crossOver(ArrayList<ArrayList<Integer>> parentA,ArrayList<ArrayList<Integer>> parentB) {
		//will return a mutated dna. DON'T FORGET TO DEEPCOPY!!
		ArrayList<ArrayList<Integer>> newDNA = new ArrayList<ArrayList<Integer>>();
		// helper function to mutate a DNA, according to some rate.
		for(int i=0;i<parentA.size();i++){
			ArrayList<Integer> dnapieceA = parentA.get(i);
			ArrayList<Integer> dnapieceB = parentB.get(i);
			ArrayList<Integer> newdnapiece = new ArrayList<Integer>();
			newDNA.add(newdnapiece);
			for(int j=0;j<parentA.get(0).size();j++){
				Double mut = ran.nextDouble();
				if (mut < 0.5) { //use parent A
					newdnapiece.add(dnapieceA.get(j));
				}else{ //else use parent B
					newdnapiece.add(dnapieceB.get(j));
				}
			}
		}
		return newDNA;
	}
	
	public ArrayList<ArrayList<Integer>> mutateDna(ArrayList<ArrayList<Integer>> DNA) {
		//will return a mutated dna. DON'T FORGET TO DEEPCOPY!!
		ArrayList<ArrayList<Integer>> newDNA = new ArrayList<ArrayList<Integer>>();
		// helper function to mutate a DNA, according to some rate.
		for(int i=0;i<DNA.size();i++){
			ArrayList<Integer> dnapiece = DNA.get(i);
			ArrayList<Integer> newdnapiece = new ArrayList<Integer>();
			newDNA.add(newdnapiece);
			for(int j=0;j<DNA.get(0).size();j++){
				Double mut = ran.nextDouble();
				if (mut < mutateRate) { //add a mutant
					int newGene = ran.nextInt(scripts.size());
					newdnapiece.add(newGene);
				}else{ //else add the old gene
					newdnapiece.add(dnapiece.get(j));
				}
			}
		}
		return newDNA;
	}
	
	public int evalDna(GameState currentState,ArrayList<ArrayList<Integer>> DNA){
		//return a score for a chromosome...
		GameState sc = currentState.clone(); // sc for state clone
		Game_POE_Simulation gc = new Game_POE_Simulation(sc, NOKplayerForEval1,
				NOKplayerForEval2, evalGameRoundLimit, scripts); //send scripts to game...
		//System.out.println("DNA length: "+DNA.size()+" DNA inner size: "+DNA.get(0).size());
		int ss = gc.dnaEvalGroup(DNA,1,this.us_id,enemy_id);//also send player id to avoid problems
		//System.out.println("score: "+ss);
		return ss; //HARDCODE EVALUATION METHOD TO 1
	}
}
